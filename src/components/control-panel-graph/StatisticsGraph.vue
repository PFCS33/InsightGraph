<template>
  <div class="statistics-graph-box">
    <BaseCard mode="flat" class="barchart-container">
      <div class="title">Link Relationship</div>

      <div class="link-filter-box">
        <div v-for="link in linkType" class="link-filter">
          <svg
            viewBox="0 0 1024 1024"
            xmlns="http://www.w3.org/2000/svg"
            :class="[
              'check-icon',
              { 'check-icon-active': selectedLinkType[link] },
            ]"
            @click="toggleSelectedLink(link)"
          >
            <path
              d="M433.1 657.7c12.7 17.7 39 17.7 51.7 0l210.6-292c3.8-5.3 0-12.7-6.5-12.7H642c-10.2 0-19.9 4.9-25.9 13.3L459 584.3l-71.2-98.8c-6-8.3-15.6-13.3-25.9-13.3H315c-6.5 0-10.3 7.4-6.5 12.7l124.6 172.8z"
            ></path>
            <path
              d="M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32z m-40 728H184V184h656v656z"
            ></path>
          </svg>
          <span> {{ link }}</span>
        </div>
      </div>
      <div id="barchart-box"></div
    ></BaseCard>
    <BaseCard mode="flat" id="histogram-box"></BaseCard>
  </div>
</template>
<script>
export default {
  data() {
    return {
      barchart: null,
      histogram: null,

      barchartConfig: [],
      linkType: ["siblings", "parent-child", "same-name"],

      filteredNodes: null,
      filterdLinks: null,
      selectedNodes: null,

      selectedLinkType: {
        siblings: true,
        "parent-child": true,
        "same-name": true,
      },
    };
  },

  computed: {
    totalData() {
      return this.$store.getters["force/totalData"];
    },
    linkGroup() {
      return this.$store.getters["force/linkDataGroup"];
    },
    nodeGroup() {
      return this.$store.getters["force/nodeDataGroup"];
    },
  },

  methods: {
    toggleSelectedLink(link) {
      this.selectedLinkType[link] = !this.selectedLinkType[link];
    },
    drawBarchart(newVal) {
      const that = this;

      if (!this.barchart) {
        const marginTop = 0;
        const marginRight = 10;
        const marginBottom = 20;
        const marginLeft = 10;
        const container = d3.select("#barchart-box");
        const width = parseInt(container.style("width"), 10);
        const height = parseInt(container.style("height"), 10);
        const colorScale = d3.scaleOrdinal(this.linkType, [
          "#F7A69F",
          "#C69DE9",
          "#53C4B6",
        ]);

        const tooltip = container
          .append("div")
          .attr("class", "tooltip")
          .style("opacity", 0);
        const svg = container
          .append("svg")
          .attr("viewBox", [0, 0, width, height])
          .attr("style", "width: 100%; height:100%;")
          .style("user-select", "none");
        const rectGroup = svg.append("g").attr("class", "rect-group");
        const xAxis = svg
          .append("g")
          .attr("class", "x-axis")
          .attr("transform", `translate(0,${height - marginBottom})`);

        this.barchartConfig.marginTop = marginTop;
        this.barchartConfig.marginRight = marginRight;
        this.barchartConfig.marginBottom = marginBottom;
        this.barchartConfig.marginLeft = marginLeft;
        this.barchartConfig.container = container;
        this.barchartConfig.width = width;
        this.barchartConfig.height = height;
        this.barchartConfig.colorScale = colorScale;
        this.barchartConfig.tooltip = tooltip;
        this.barchart = true;
      }
      const config = this.barchartConfig;
      const y = d3
        .scaleBand()
        .domain(this.linkType.filter((d) => this.selectedLinkType[d]))
        .range([config.marginTop, config.height - config.marginBottom])
        .padding(0.1);

      const x = d3
        .scaleLinear()
        .domain([0, d3.max(newVal, (d) => d.count)])
        .nice()
        .range([config.marginLeft, config.width - config.marginRight]);

      config.container
        .select("svg")
        .select(".rect-group")
        .selectAll("rect")

        .data(newVal, (d) => d.type)
        .join(
          (enter) => {
            enter
              .append("rect")
              .on("mouseover", mouseover)
              .on("mousemove", mousemove)
              .on("mouseleave", mouseleave)
              .transition()
              .duration(300)
              .attr("cursor", "pointer")
              .attr("fill", (d) => config.colorScale(d.type))
              .attr("x", (d) => x(0))
              .attr("y", (d) => y(d.type))
              .attr("width", (d) => x(d.count) - x(0))
              .attr("height", y.bandwidth());
          },
          (update) => {
            update
              .transition()
              .duration(300)
              .attr("cursor", "pointer")
              .attr("fill", (d) => config.colorScale(d.type))
              .attr("x", (d) => x(0))
              .attr("y", (d) => y(d.type))
              .attr("width", (d) => x(d.count) - x(0))
              .attr("height", y.bandwidth());
          },
          (exit) => {
            exit
              .attr("opacity", 1)
              .attr("pointer-events", "none")
              .transition()
              .duration(100)
              .attr("opacity", 0)
              .remove();
          }
        );
      config.container
        .select("svg")
        .select(".x-axis")
        .transition()
        .duration(300)
        .call(d3.axisBottom(x).ticks(8))
        .select(".domain")
        .attr("stroke-opacity", 0);

      function mouseover(event, d) {
        config.tooltip.transition().duration(250).style("opacity", 1);
        d3.select(this).classed("barchart-hover-highlight", true);
      }
      function mousemove(event, d) {
        config.tooltip
          .html(`${d.type}: ${d.count}`)
          .style("left", event.x + 15 + "px")
          .style("top", event.y + "px");
      }
      function mouseleave(event, d) {
        config.tooltip.transition().duration(250).style("opacity", 0);
        d3.select(this).classed("barchart-hover-highlight", false);
      }
    },
    drawHistogram(newVal) {
      const that = this;
      if (this.histogram) {
        // update data
      } else {
        const container = d3.select("#histogram-box");
        // 获取总宽和高
        const width = parseInt(container.style("width"), 10);
        const height = parseInt(container.style("height"), 10);
        // 获取 总insight-type 类型
        const types = Array.from(newVal.keys());
        // 获取每个子图的高
        const subHeight = Math.floor(height / types.length);
        // 设置每个子图的margin
        const marginTop = 0;
        const marginRight = 10;
        const marginBottom = 15;
        const marginLeft = width * 0.2;
        // 创建svg画布
        const svg = container
          .append("svg")
          .attr("viewBox", [0, 0, width, height])
          .attr("style", "width: 100%; height:100%;")
          .style("user-select", "none");
        // 创建分箱器，使用FreedmanDiaconis公式
        const bin = d3.bin().value((d) => d.score);
        // .thresholds(d3.thresholdFreedmanDiaconis);
        types.forEach((type, index) => {
          const value = newVal.get(type);
          const bins = bin(value.scores);
          console.log(bins);
          const g = svg
            .append("g")
            .attr("class", `${type}-box`)
            .attr("transform", `translate(0,${index * subHeight})`);

          const x = d3
            .scaleLinear()
            .domain([bins[0].x0, bins[bins.length - 1].x1])
            .range([marginLeft, width - marginRight]);

          const y = d3
            .scaleLinear()
            .domain([0, d3.max(bins, (d) => d.length)])
            .range([subHeight - marginBottom, marginTop]);
          g.append("g")
            .attr("fill", "steelblue")
            .attr("class", "rect-group")
            .selectAll()
            .data(bins)
            .join("rect")
            .attr("x", (d) => {
              if (d.x0 === 1) {
                return marginLeft;
              } else {
                return x(d.x0) + 1;
              }
            })
            .attr("width", (d) => {
              const rectWidth = x(d.x1) - x(d.x0);
              if (rectWidth === 0) {
                return width - marginLeft - marginRight;
              } else {
                return rectWidth - 1;
              }
            })
            .attr("y", (d) => y(d.length))
            .attr("height", (d) => y(0) - y(d.length));
          g.append("g")
            .attr("class", "x-axis")
            .attr("transform", `translate(0,${subHeight - marginBottom})`)
            .call(d3.axisBottom(x).ticks(5).tickSizeOuter(0).tickSize(4))
            .call((g) => g.attr("font-size", "0.8rem"));
        });

        //    const piechart = echarts.init(container, "myTheme");
        // const option = {
        //   title: {
        //     text: "Insight Type",
        //     left: "center",
        //     top: "4%",
        //     textStyle: {
        //       color: "#555",
        //       fontSize: 13,
        //     },
        //   },
        //   legend: {
        //     top: "13%",
        //     left: "5%",

        //     textStyle: {
        //       fontSize: 10,
        //       color: "#555",
        //     },
        //     itemWidth: 18,
        //     itemGap: 5,
        //   },
        //   tooltip: {
        //     trigger: "item",
        //     textStyle: {
        //       color: "#555",
        //       fontSize: 12,
        //     },
        //   },
        //   grid: {
        //     left: "5%",
        //     right: "10%",
        //     bottom: "10%",
        //     top: "33%",
        //     containLabel: true,
        //   },

        //   series: [
        //     {
        //       name: "insight-type",
        //       stillShowZeroSum: false,
        //       type: "pie",
        //       data: newVal.sort(function (a, b) {
        //         return a.value - b.value;
        //       }),
        //       radius: ["5%", "55%"],
        //       center: ["50%", "70%"],
        //       roseType: "area",
        //       itemStyle: {
        //         borderRadius: 4,
        //       },
        //       labelLine: {
        //         smooth: 0.2,
        //         length: 5,
        //         length2: 10,
        //       },
        //       emphasis: {
        //         itemStyle: {
        //           shadowBlur: 10,
        //           shadowOffsetX: 0,
        //           shadowColor: "rgba(0, 0, 0, 0.5)",
        //         },
        //       },
        //     },
        //   ],
        // };
        // piechart.setOption(option);
        // this.piechart = piechart;
        // piechart.on("legendselectchanged", function (params) {
        //   const filteredNodes = that.filteredNodes
        //     ? that.filteredNodes
        //     : that.totalData.nodes;
        //   const selectedLinks = that.filterdLinks
        //     ? that.filterdLinks
        //     : that.totalData.links;

        //   const selectedNodeData = filteredNodes.filter(
        //     (d) =>
        //       params.selected[d["insight-list"][d.insightIndex]["insight-type"]]
        //   );

        //   const idMap = new Set();
        //   selectedNodeData.forEach((node) => {
        //     idMap.add(node.id);
        //   });
        //   const filteredLinks = selectedLinks.filter(
        //     (d) => idMap.has(d.source) && idMap.has(d.target)
        //   );

        //   that.$store.dispatch("force/groupByLinkType", filteredLinks);
        //   that.$store.dispatch("force/groupByNodeType", selectedNodeData);
        //   that.$store.commit("force/setSelectedData", {
        //     nodes: selectedNodeData,
        //     links: filteredLinks,
        //   });
        // });
      }
    },
  },
  watch: {
    // totalData(newVal) {
    //   if (newVal) {
    //     const idMap = new Set();
    //     newVal.nodes.forEach((node) => {
    //       idMap.add(node.id);
    //     });
    //     this.idMap = idMap;
    //   }
    // },
    linkGroup(newVal) {
      if (newVal) {
        this.drawBarchart(newVal);
      }
    },
    nodeGroup(newVal) {
      if (newVal) {
        this.drawHistogram(newVal);
      }
    },
    selectedLinkType: {
      deep: true,
      handler(newVal) {
        const that = this;
        const totalLinks = that.totalData.links;
        const totalNodes = that.totalData.nodes;

        const selectedLinkData = totalLinks.filter((d) => newVal[d.type]);

        const selectedId = new Set();
        selectedLinkData.forEach((link) => {
          const sourceId = link.source;
          const targetId = link.target;
          selectedId.add(sourceId);
          selectedId.add(targetId);
        });

        const unSelectedId = new Set();
        const unSelectedLinkData = totalLinks.filter((d) => !newVal[d.type]);

        unSelectedLinkData.forEach((link) => {
          const sourceId = link.source;
          const targetId = link.target;

          unSelectedId.add(sourceId);
          unSelectedId.add(targetId);
        });

        const unSelectedIdFixed = new Set(
          [...unSelectedId].filter((x) => !selectedId.has(x))
        );

        const filteredNodes = totalNodes.filter(
          (d) => !unSelectedIdFixed.has(d.id)
        );
        that.filteredNodes = filteredNodes;
        that.filterdLinks = selectedLinkData;
        that.$store.dispatch("force/groupByLinkType", selectedLinkData);
        that.$store.dispatch("force/groupByNodeType", filteredNodes);
        that.$store.commit("force/setSelectedData", {
          nodes: filteredNodes,
          links: selectedLinkData,
        });
        that.piechart.dispatchAction({
          type: "legendAllSelect",
        });
      },
    },
  },

  created() {},
};
</script>

<style scoped>
.statistics-graph-box {
  width: 100%;
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  gap: 0.5vw;

  background-color: #fff;
}
.barchart-container {
  flex: 0.3;
  background-color: #fff;
  transition: border-color 0.3s, box-shadow 0.3s;
  display: flex;
  flex-direction: column;
  gap: 0.3vw;
}
#histogram-box {
  width: 100%;

  flex: 0.7;
  background-color: #fff;
  transition: border-color 0.3s, box-shadow 0.3s;
}
.link-filter-box {
  display: flex;
  width: 100%;
  justify-content: center;
  gap: 4%;
  flex-grow: 0;
  user-select: none;
}
.link-filter {
  display: flex;
  align-items: center;
  gap: 0.3rem;
}
#barchart-box {
  flex-grow: 1;
}

#histogram-box:hover,
.barchart-container:hover {
  box-shadow: 1px 4px 6px 1px rgba(0, 0, 0, 0.26);
}

.title {
  font-weight: bold;
  font-size: 16px;
  text-align: center;
  color: #545b77;
  margin: 0.2vw 0;
  margin-top: 0.6vw;
  flex-grow: 0;
}
.check-icon {
  cursor: pointer;

  width: 15px;
  height: 15px;

  border-radius: 2px;
  fill: #545b77;
  background-color: #fff;
  transition: background-color 0.2s, fill 0.2s;
}

.check-icon:hover,
.check-icon:active {
  background-color: #545b77;
  fill: #fff;
}
.check-icon-active {
  background-color: #858eb5;
  fill: #fff;
}
</style>

<style>
.barchart-hover-highlight {
  filter: brightness(110%);

  transition: filter 0.2s;
}
</style>
